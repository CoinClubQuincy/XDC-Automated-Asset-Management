### How Brokerage DApps can change trade finance on the XDC network

Most of the crypto space is quite familiar with the notion of NFTs and marketplaces. Typically, when people refer to these different types of instruments in Blockchain technology, they often refer shallowly to pictures being sold in the new online markets. This tends to create a misconception that NFTs are merely pictures, rather than a shared accounting tool to represent a particular object of ownership. NFTs are unique digital objects residing within smart contracts that can be used as units of account by shared applications. These objects can be referenced as derivative objects, such as a representation of a stock or a currency, or they could be abstract representations of some piece of code, like possessing a token to allow access to an application, using it as a key license, or even keeping track of scores.

Previously, I wrote a smart contract to create a representation of an asset as a token in my article titled "A Conceptualization on How Brokers, Banks, and Financial Institutions can Tokenize Assets on XDC": 

[(https://www.xdc.dev/yourbroquincy/a-conceptualization-on-how-brokersbanks-and-finance-institutions-can-tokenize-assets-on-xdc-2g17)]

In that article, I explained how a token can be used as a unit of account for traditional assets, similar to how assets can be represented in a database. What makes the token special on the blockchain is that it can be referenced by third-party applications like marketplaces and other DApps. In this article, I aim to articulate how new markets can be formed and how tokenized assets can be automated in these new marketplaces.

To demonstrate how you can automate assets on XDC, I forked an NFT marketplace repository from TronzitVecaâ€™s ERC1155-Marketplace-Contract. Using my previous Assets contract and creating a portfolio contract, I managed to create a 4-contract DApp that enables the Marketplace to trade assets and a portfolio to manage assets for users, and allowing them to interact with the marketplace.
A DApp like this is analogous to an application like Robinhood, but with three main differences:

1. The infrastructure is self-hosted. So any broker interacting with this application does not need to set up or manage in infrastructure of the application


2. Users can self-custody assets via access to their portfolio contract, enabling them to move between different marketplaces and brokers with ease. The user has a portfolio generated by the original broker but can take that portfolio to other brokers while remaining in potential compliance rules established by the portfolio and marketplace.


3. Broker-dealers and other firms can engage with each other via the decentralized marketplaces. Other broker-dealers can allow their users portfolios to interact with the marketplaces, providing more options to their users and additional liquidity in their marketplace.

As more broker-dealers create their marketplaces tailored to their clientele, the number of financial participants and the necessary liquidity for exchanges will exponentially increase. Each broker can access the marketplaces of others, and clients from different brokers can access the assets of other marketplaces if liquidity is needed locally. 

This enables easier and faster trading between partners and investors. Traditionally, trading between finance partners required intricate relationships and redundant record-keeping. With partners using the XDC network as a shared accounting system, asset transfers become significantly quicker, and partners don't need to sync extensively to ensure accurate recording. What used to take days can now happen in seconds.
Similar to how social media enabled greater online connections, blockchain technology allows banks and financial institutions to trade over the internet on the blockchain with more parties than they could otherwise.


This contract can be broken into 4 parts
1. Marketplace Contract [https://github.com/TronzitVeca/ERC1155-Marketplace-Contract]The marketplace is where the Assets are located to be traded, this is no different than most NFT marketplaces the main difference being The assets held in this one are Tradition assets listed by broker-Dealers to help facilitated the sale to 

2. Portfolio Ledger
The portfolio Ledger is a contract that generate Portfolio contracts and keeps track of all the users who are interacting with a particular Marketplace These portfolios can be possessed by other brokers or just investors interacting with the Marketplace

3. Portfolio contract
The portfolio contract is a way for users to directly interact with the Marketplace and custody Assets, that acts a a basket that can manage and interact with 3rd party assets while giving 

4. The Asset that gets traded [(https://www.xdc.dev/yourbroquincy/a-conceptualization-on-how-brokersbanks-and-finance-institutions-can-tokenize-assets-on-xdc-2g17)] The underlying Asset that get traded and owned within this application


**Portfolio Ledger**

```solidity

contract portfolioLedger{
    string portfolioTokenURI;   //URI formart for users
    address marketplaceAddress; //address of marketplace Contract

    uint totalAccounts = 0;
    
    constructor(uint _totalHandlers,string memory _URI,string memory _marketplaceName){
        portfolioTokenURI = _URI;
        marketplaceAddress = address(new Marketplace(_totalHandlers,_URI,_marketplaceName));
        totalAccounts++;
    }
    mapping(string => Ledger) ledger;
    mapping(uint => numberLedger) numbLedger;
    struct Ledger{
        string account;
        uint accountNumber;
        address portfolio;
        bool exist;
    }
    struct numberLedger{
        string account;
        address portfolio;  
        bool exist; 
    }
    //Create new User Account
    function createAccount(string memory _account)public returns(string memory,address){
        require(ledger[_account].exist == false, "account already exist");
        address portfolioContractAddress; 
        portfolioContractAddress = address(new Portfolio(portfolioTokenURI,_account,address(this),marketplaceAddress,msg.sender));
        ledger[_account] = Ledger(_account,totalAccounts,portfolioContractAddress,true);
        numbLedger[totalAccounts] = numberLedger(_account,portfolioContractAddress,true);
        totalAccounts++;
        return ("new account created", portfolioContractAddress);
    }
    //check and view new user Account
    function checkAccount(string memory _account,uint accountNumber)public returns(string memory,address,bool){
        if(ledger[_account].exist = true || numbLedger[accountNumber].exist){
            return (ledger[_account].account,ledger[_account].portfolio,ledger[_account].exist);
        }else{
            return ("none",0x0000000000000000000000000000000000000000,false);
        }
    }
    //forward funds from one user name to another
    function forwardFunds(string memory _reciver)external payable returns(bool){
        string memory account_;
        address portfolio_;
        bool exist_;
        (account_, portfolio_, exist_) = checkAccount(_reciver,0);
        require(exist_ == true, "User does not exist");
        payable(portfolio_).transfer(msg.value);
        return true;
    }
}
```



**Portfolio Contract**

```solidity
contract Portfolio is ERC1155{
    uint public handlerToken;
    string public accountName;
    uint marketplaceCount =0;

    Marketplace public marketplace;
    portfolioLedger public DAppLedger;
    address private ledgerPrivate;
    address currentOwner;

    event changedMarketPlace(string _newmarketplace);
    event changedOwner(string _brokerMSG,address _newOwner);

    mapping(address => savedMarketPlaces) savedmarketplace;
    mapping(uint => savedMarketPlaces) marketplaceNumber;
    struct savedMarketPlaces{
        address marketplaceAddress;
        string marketplaceName;
        bool exist;
    }

    constructor(string memory _URI,string memory _name,address _DAppLedger,address _marketplace,address user) ERC1155(_URI) {
        handlerToken = uint(keccak256(abi.encodePacked(_URI)));
        _mint(user,handlerToken,1, "");

        accountName = _name;
        ledgerPrivate = _DAppLedger;
        DAppLedger = portfolioLedger(_DAppLedger);
        marketplace = Marketplace(_marketplace);
        
        logNewMarketPlace(address(_marketplace));
        
        currentOwner = user;
    }
    modifier broker{
        require(marketplace.balanceOf(msg.sender,marketplace.handlerToken()) >= 1, "broker does not hold handler token");
        _;
    }
    modifier handler{
        require(balanceOf(msg.sender,handlerToken) >= 1, "user does not hold handler token");
        _;
    }
    function resetOwner(address _newOwner) public broker returns(address){
           _mint(_newOwner,handlerToken,1, "");
           _burn(currentOwner,handlerToken,1);
           currentOwner = _newOwner;

           emit changedOwner("The registerd broker has chaged the owner of this contract",_newOwner);
           return _newOwner;
    }

//Delegate functions that interact directly with the marketplace
}
```

The future of blockchain technology is about connecting siloed entities that struggle with maintaining settlement and moving capital among multiple parties globally. With the XDC network and connected markets, the means of connection have never been easier. Marketplaces can reference liquidity from other marketplaces directly, brokers can interact without intermediaries, and investors can self-custody assets, enabling more people to participate directly. This reduces the cost and ease of access to financial services, with the barrier to entry lowered to having an internet connection.

The more participant that operate in this way the more engagement this online economy can facilitate an the better the trade volume globally.


**Github:** https://github.com/CoinClubQuincy/XDC-BrokerageDapp